let x = 10;
const s = make_serializer();
concurrent_execute(
  () => {
    x = s(() => x * x)();
  },
  s(() => {
    x = x + 1;
  })
);

// concurrent_execute의 인수 f1, f2는 같은 직렬화 집합에 속하지 않기 때문에 동시에 실행된다.

// s(() => x * x)와 s(() => { x = x + 1;})는 같은 직렬화 집합에 속하기 때문에 동시에 실행되지 않는다.
// 즉 T1이 x * x 를 평가하는 동안에는 T2가 함수 x = x + 1을 평가할 수 없다.

// 101: T1이 x를 100으로 설정한 다음 T2가 x를 101로 증가한다.
// 121: T2가 x를 11로 증가한 다음 T1가 x를 121로 설정한다.
// 11: T1의 s(() => x * x)()의 평가가 완료된 후 x를 배정할 때 T2가 실행된다면 x = 11이 된다.

// f1은 직렬화되지 않은 함수이기 때문에 f1 내부에서는 얼마든지 f2함수가 동시에 실행될 수 있다.
// 단, s( () => x * x)가 평가될 때에는 f2가 실행되지 않는다.
// 따라서 s( () => x * x)이 평가되기 전, 후에 f2가 실행되는 경우에 대해서만 생각해보면 된다.
const f1 = () => {
  x = s(() => x * x)();
};
